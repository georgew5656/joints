defpackage joinery :
  import core
  import collections
  import math
  import geom
  import clipper
  import font
  import libfive
  import primitives

val wood_thickness:Float = 4.0f
var ind:Int = 0

defn trapezoid (base1:Float, base2:Float, height:Float) -> Polygon:
  var point1 = V2f(-1.0f * base1 / 2.0f ,-1.0f * height / 2.0f)
  var point2 = V2f(base1 / 2.0f, -1.0f * height / 2.0f)
  var point3 = V2f(base2 / 2.0f, height / 2.0f)
  var point4 = V2f(-1.0f * base2 / 2.0f, height / 2.0f)
  Polygon([Contour([point1, point2, point3, point4])])

;; current place is to slice the joints and stick the pieces together, this would technically only approximate the dovetail joints

;; alternatively could use framing to support 3d construction of the joint (this is recursive)

;; we should probably stack up until we have enough depth for things to work. also we can use pins to hold wood together.

;; would it be better to just use very thin 3d printed objects?

;; Utility Functions
defn point_generator (proportions:V3f) -> (Box3f -> V3f) :
  defn custom_point_selector (b:Box3f) -> V3f :
    var distance = minus(hi(b), lo(b))
    var x1 = x(lo(b)) + x(distance) * x(proportions)
    var y1 = y(lo(b)) + y(distance) * y(proportions)
    var z1 = z(lo(b)) + z(distance) * z(proportions)
    V3f(x1, y1, z1)
  custom_point_selector

;;special point selector that is frequently used
val mid = point_generator(V3f(0.5f, 0.5f, 0.5f))

;;write shape to stl file
defn to_disk (shape:Shape):
  save(string-join(["test", to-string(ind), ".stl"]), shape)
  ind = ind + 1

;;generate_point to write to stl for debugging
defn generate_point (location:V3f) -> Shape :
  var c = cube(1.0f)
  mov(location, c)
;; parallel->gooseneck
;;corner_right->dovetail_blind
;;middle_right->dovetail_dado

;;Connection Functions

;;based off of x,y,z selector functions, generate a connection point between two shapes.
defn connection_point (bnds:Box3f, d1:Box3f -> V3f, d2:Box3f -> V3f, d3:Box3f -> V3f)  -> V3f :
  V3f(x(d1(bnds)), y(d2(bnds)), z(d3(bnds)))

;; add pin hole to wood at specified pin locations, will probably have to 3d print the pins.
defn add_pins (shape:Shape, pin_locations:Tuple<V3f>, pin_diameter:Float, pin_height:Float) :
  var pinned_shape = shape
  val pin_locations_array = to-array<V3f>(pin_locations)
  val pins = Array<Shape>(length(pin_locations_array))
  val primitive = pin(pin_diameter, pin_height)
  for i in 0 to length(pin_locations_array) do :
    var pinned_location = mov(pin_locations_array[i], primitive)
    pinned_shape = rem(pinned_shape, pinned_location)
    pins[i] = pinned_location
  [shape, pin_locations]

;; add connector joints to the male, female shapes.
defn add_connectors (male:Shape, female:Shape, connection_points:Tuple<Array<V3f>>, key:(Float, Float) -> Shape, width:Float, l:Float) -> Tuple<Shape>:
  val cp_array = to-array<Array<V3f>>(connection_points)
  var male_joints = male
  var female_joints = female
  for i in 0 to length(cp_array) do :
    var connection_point = cp_array[i]
    male_joints = add_connection_male(male_joints, connection_point[0], key, width, l)
    female_joints = add_connection_female(female_joints, connection_point[1], key, width, l)
  [male_joints, female_joints]

defn add_connection_male (shape:Shape, cp:V3f, key:(Float, Float) -> Shape, width:Float, l:Float) -> Shape:
  var rotated_cp = y3f(magnitude(cp))
  var rotated_shape = rot(cp, rotated_cp, shape)
  var connector = key(width, l)
  var connector_cp = connection_point(bounds(connector), mid, lo, mid)
  var joint = union(attach(connector, connector_cp, rotated_shape, rotated_cp))
  rot(rotated_cp, cp, joint)

defn add_connection_female (shape:Shape, cp:V3f, key:(Float, Float) -> Shape, width:Float, length:Float) -> Shape:
  var rotated_cp = y3f(magnitude(cp))
  var rotated_shape = rot(cp, rotated_cp, shape)
  var connector = key(width, length)
  var connector_cp = connection_point(bounds(connector), mid, lo, mid)
  var overlapped = to-array<Shape>(attach(connector, connector_cp, rotated_shape, rotated_cp))
  rot(rotated_cp, cp, rem(overlapped[1], overlapped[0]))

;;Connector Primitives

;;perpindicular joint
defn dovetail_dado_primitive (width:Float, length:Float) -> Shape:
  var slice_in = tenon(V3f(width, length / 6.0f, wood_thickness))
  var neck = extrude(wood_thickness / 2.0f ,to-shape(trapezoid(width / 4.0f, width / 2.0f ,length / 2.0f)))
  var hat = tenon(V3f(width * 2.0f / 3.0f, width / 3.0f, wood_thickness / 2.0f))
  neck = union(attach(slice_in, connection_point(bounds(slice_in), mid, hi, hi), neck, connection_point(bounds(neck), mid, lo, hi)))
  val joint = union(attach(hat, connection_point(bounds(hat), mid, lo, hi), neck, connection_point(bounds(neck), mid, hi, hi)))
  joint

;; corner joint
defn dovetail_blind_primitive (width:Float, length:Float) -> Shape:
  var face = trapezoid(width, 2.0f * width, length)
  var joint = extrude(length, to-shape(face))
  rot-z(90.0f, rot-y(90.0f, joint))

;; parallel joint
defn gooseneck_primitive (width:Float, length:Float) -> Shape :
  var left_tenon = tenon(V3f(width / 3.0f, width / 6.0f, wood_thickness / 2.0f))
  var right_tenon = tenon(V3f(width / 3.0f, width / 6.0f, wood_thickness / 2.0f))
  var middle_tenon = tenon(V3f(width / 3.0f, width / 6.0f, wood_thickness / 2.0f))

  var neck = extrude(wood_thickness / 2.0f, to-shape(polygon-rect(V2f(width / 3.0f, length * 0.75f))))
  neck = union(attach(left_tenon, connection_point(bounds(left_tenon), hi, lo, mid), neck, connection_point(bounds(neck), lo, lo, mid)))
  neck = union(attach(right_tenon, connection_point(bounds(right_tenon), lo, lo, mid), neck, connection_point(bounds(neck), hi, lo, mid)))

  var tapering_slope = wood_thickness / 10.0f
  var head_top = trapezoid(width / 2.0f, width / 4.0f, length * 0.25f)
  var head_bottom = trapezoid(width / 2.0f - tapering_slope, width / 4.0f - tapering_slope, length * 0.25f)
  var head = loft(wood_thickness / 2.0f, to-shape(head_bottom), to-shape(head_top))

  var joint = union(attach(head, connection_point(bounds(head), mid, lo, mid), neck, connection_point(bounds(neck), mid, hi, mid)))
  joint = union(attach(middle_tenon, connection_point(bounds(middle_tenon), mid, lo, hi), joint, connection_point(bounds(joint), mid, lo, lo)))
  joint

defn pin (pin_diameter:Float, pin_height:Float) :
  cylinder(pin_diameter, pin_height)


defn tenon (dimensions:V3f) -> Shape:
  var tenon = to-shape(polygon-rect(V2f(x(dimensions), y(dimensions))))
  extrude(z(dimensions), tenon)

;;Test Functions

defn test_gooseneck () :
  to_disk(gooseneck_primitive(4.0f, 6.0f))
  var side1 = extrude(wood_thickness, rect(10.0f, 10.0f))
  var side2 = extrude(wood_thickness, rect(10.0f, 10.0f))
  var connected = to-array<Shape>(attach(side1, connection_point(bounds(side1), hi, mid, mid),side2, connection_point(bounds(side2), lo, mid, mid)))
  var c_points = [to-array<V3f>([connection_point(bounds(connected[0]), hi, mid, mid),  connection_point(bounds(connected[0]), hi, mid, mid) ])]
  val connected_pieces = to-array<Shape>(add_connectors(connected[1], connected[0], c_points, gooseneck_primitive, 4.0f, 6.0f))
  to_disk(connected_pieces[0])
  to_disk(connected_pieces[1])

defn test_dado () :
  var shape1 = extrude(wood_thickness, rect(20.0f, 10.0f))
  var shape2 = extrude(wood_thickness, rect(10.0f, 20.0f))
  var connected = to-array<Shape>(attach(shape1, connection_point(bounds(shape1), mid, lo, mid), shape2, connection_point(bounds(shape2), mid, hi, mid)))
  var c_points = [to-array<V3f>([connection_point(bounds(connected[0]), mid, lo, mid), connection_point(bounds(connected[0]), mid, lo, mid)])]
  val connected_pieces = to-array<Shape>(add_connectors(connected[1], connected[0],c_points, dovetail_dado_primitive, 6.0f, 4.0f))
  to_disk(connected_pieces[0])
  to_disk(connected_pieces[1])

defn test_dovetail () :
  var shape1 = extrude(wood_thickness, rect(5.0f, 15.0f))
  var shape2 = extrude(wood_thickness, rect(15.0f, 5.0f))
  var offset = 2.5f / 15.0f
  var custom = point_generator(V3f(1.0f - offset, 1.0f - offset, 1.0f - offset))
  var connected = to-array<Shape>(attach(shape1, connection_point(bounds(shape1) , lo, custom, mid), shape2, connection_point(bounds(shape2), hi, mid, mid)))
  var c_points = [to-array<V3f>([connection_point(bounds(connected[1]), hi, mid, mid), connection_point(bounds(connected[0]), lo, custom, mid)])]
  val connected_pieces = to-array<Shape>(add_connectors(connected[1], connected[0], c_points, dovetail_blind_primitive, 1.0f, 5.0f))
  to_disk(union([connected_pieces[0]]))
  to_disk(union([connected_pieces[1]]))

defn main () :
  test_dovetail()
main()
